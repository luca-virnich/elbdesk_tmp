// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'artwork_color_specification.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ArtworkColorSpecification _$ArtworkColorSpecificationFromJson(
    Map<String, dynamic> json) {
  return _ArtworkColorSpecification.fromJson(json);
}

/// @nodoc
mixin _$ArtworkColorSpecification {
  String? get name => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  String? get book => throw _privateConstructorUsedError;
  String? get egname => throw _privateConstructorUsedError;
  double? get frequency => throw _privateConstructorUsedError;
  double? get angle => throw _privateConstructorUsedError;
  String? get dotshape => throw _privateConstructorUsedError;
  double? get r => throw _privateConstructorUsedError;
  double? get g => throw _privateConstructorUsedError;
  double? get b => throw _privateConstructorUsedError;
  String? get attribute => throw _privateConstructorUsedError;
  String? get printingmethod => throw _privateConstructorUsedError;
  ArtworkColor? get databaseColor => throw _privateConstructorUsedError;

  /// Serializes this ArtworkColorSpecification to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ArtworkColorSpecification
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ArtworkColorSpecificationCopyWith<ArtworkColorSpecification> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ArtworkColorSpecificationCopyWith<$Res> {
  factory $ArtworkColorSpecificationCopyWith(ArtworkColorSpecification value,
          $Res Function(ArtworkColorSpecification) then) =
      _$ArtworkColorSpecificationCopyWithImpl<$Res, ArtworkColorSpecification>;
  @useResult
  $Res call(
      {String? name,
      String? type,
      String? book,
      String? egname,
      double? frequency,
      double? angle,
      String? dotshape,
      double? r,
      double? g,
      double? b,
      String? attribute,
      String? printingmethod,
      ArtworkColor? databaseColor});

  $ArtworkColorCopyWith<$Res>? get databaseColor;
}

/// @nodoc
class _$ArtworkColorSpecificationCopyWithImpl<$Res,
        $Val extends ArtworkColorSpecification>
    implements $ArtworkColorSpecificationCopyWith<$Res> {
  _$ArtworkColorSpecificationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ArtworkColorSpecification
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? type = freezed,
    Object? book = freezed,
    Object? egname = freezed,
    Object? frequency = freezed,
    Object? angle = freezed,
    Object? dotshape = freezed,
    Object? r = freezed,
    Object? g = freezed,
    Object? b = freezed,
    Object? attribute = freezed,
    Object? printingmethod = freezed,
    Object? databaseColor = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      book: freezed == book
          ? _value.book
          : book // ignore: cast_nullable_to_non_nullable
              as String?,
      egname: freezed == egname
          ? _value.egname
          : egname // ignore: cast_nullable_to_non_nullable
              as String?,
      frequency: freezed == frequency
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as double?,
      angle: freezed == angle
          ? _value.angle
          : angle // ignore: cast_nullable_to_non_nullable
              as double?,
      dotshape: freezed == dotshape
          ? _value.dotshape
          : dotshape // ignore: cast_nullable_to_non_nullable
              as String?,
      r: freezed == r
          ? _value.r
          : r // ignore: cast_nullable_to_non_nullable
              as double?,
      g: freezed == g
          ? _value.g
          : g // ignore: cast_nullable_to_non_nullable
              as double?,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as double?,
      attribute: freezed == attribute
          ? _value.attribute
          : attribute // ignore: cast_nullable_to_non_nullable
              as String?,
      printingmethod: freezed == printingmethod
          ? _value.printingmethod
          : printingmethod // ignore: cast_nullable_to_non_nullable
              as String?,
      databaseColor: freezed == databaseColor
          ? _value.databaseColor
          : databaseColor // ignore: cast_nullable_to_non_nullable
              as ArtworkColor?,
    ) as $Val);
  }

  /// Create a copy of ArtworkColorSpecification
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ArtworkColorCopyWith<$Res>? get databaseColor {
    if (_value.databaseColor == null) {
      return null;
    }

    return $ArtworkColorCopyWith<$Res>(_value.databaseColor!, (value) {
      return _then(_value.copyWith(databaseColor: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ArtworkColorSpecificationImplCopyWith<$Res>
    implements $ArtworkColorSpecificationCopyWith<$Res> {
  factory _$$ArtworkColorSpecificationImplCopyWith(
          _$ArtworkColorSpecificationImpl value,
          $Res Function(_$ArtworkColorSpecificationImpl) then) =
      __$$ArtworkColorSpecificationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      String? type,
      String? book,
      String? egname,
      double? frequency,
      double? angle,
      String? dotshape,
      double? r,
      double? g,
      double? b,
      String? attribute,
      String? printingmethod,
      ArtworkColor? databaseColor});

  @override
  $ArtworkColorCopyWith<$Res>? get databaseColor;
}

/// @nodoc
class __$$ArtworkColorSpecificationImplCopyWithImpl<$Res>
    extends _$ArtworkColorSpecificationCopyWithImpl<$Res,
        _$ArtworkColorSpecificationImpl>
    implements _$$ArtworkColorSpecificationImplCopyWith<$Res> {
  __$$ArtworkColorSpecificationImplCopyWithImpl(
      _$ArtworkColorSpecificationImpl _value,
      $Res Function(_$ArtworkColorSpecificationImpl) _then)
      : super(_value, _then);

  /// Create a copy of ArtworkColorSpecification
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? type = freezed,
    Object? book = freezed,
    Object? egname = freezed,
    Object? frequency = freezed,
    Object? angle = freezed,
    Object? dotshape = freezed,
    Object? r = freezed,
    Object? g = freezed,
    Object? b = freezed,
    Object? attribute = freezed,
    Object? printingmethod = freezed,
    Object? databaseColor = freezed,
  }) {
    return _then(_$ArtworkColorSpecificationImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      book: freezed == book
          ? _value.book
          : book // ignore: cast_nullable_to_non_nullable
              as String?,
      egname: freezed == egname
          ? _value.egname
          : egname // ignore: cast_nullable_to_non_nullable
              as String?,
      frequency: freezed == frequency
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as double?,
      angle: freezed == angle
          ? _value.angle
          : angle // ignore: cast_nullable_to_non_nullable
              as double?,
      dotshape: freezed == dotshape
          ? _value.dotshape
          : dotshape // ignore: cast_nullable_to_non_nullable
              as String?,
      r: freezed == r
          ? _value.r
          : r // ignore: cast_nullable_to_non_nullable
              as double?,
      g: freezed == g
          ? _value.g
          : g // ignore: cast_nullable_to_non_nullable
              as double?,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as double?,
      attribute: freezed == attribute
          ? _value.attribute
          : attribute // ignore: cast_nullable_to_non_nullable
              as String?,
      printingmethod: freezed == printingmethod
          ? _value.printingmethod
          : printingmethod // ignore: cast_nullable_to_non_nullable
              as String?,
      databaseColor: freezed == databaseColor
          ? _value.databaseColor
          : databaseColor // ignore: cast_nullable_to_non_nullable
              as ArtworkColor?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ArtworkColorSpecificationImpl extends _ArtworkColorSpecification {
  const _$ArtworkColorSpecificationImpl(
      {this.name,
      this.type,
      this.book,
      this.egname,
      this.frequency,
      this.angle,
      this.dotshape,
      this.r,
      this.g,
      this.b,
      this.attribute,
      this.printingmethod,
      this.databaseColor})
      : super._();

  factory _$ArtworkColorSpecificationImpl.fromJson(Map<String, dynamic> json) =>
      _$$ArtworkColorSpecificationImplFromJson(json);

  @override
  final String? name;
  @override
  final String? type;
  @override
  final String? book;
  @override
  final String? egname;
  @override
  final double? frequency;
  @override
  final double? angle;
  @override
  final String? dotshape;
  @override
  final double? r;
  @override
  final double? g;
  @override
  final double? b;
  @override
  final String? attribute;
  @override
  final String? printingmethod;
  @override
  final ArtworkColor? databaseColor;

  @override
  String toString() {
    return 'ArtworkColorSpecification(name: $name, type: $type, book: $book, egname: $egname, frequency: $frequency, angle: $angle, dotshape: $dotshape, r: $r, g: $g, b: $b, attribute: $attribute, printingmethod: $printingmethod, databaseColor: $databaseColor)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ArtworkColorSpecificationImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.book, book) || other.book == book) &&
            (identical(other.egname, egname) || other.egname == egname) &&
            (identical(other.frequency, frequency) ||
                other.frequency == frequency) &&
            (identical(other.angle, angle) || other.angle == angle) &&
            (identical(other.dotshape, dotshape) ||
                other.dotshape == dotshape) &&
            (identical(other.r, r) || other.r == r) &&
            (identical(other.g, g) || other.g == g) &&
            (identical(other.b, b) || other.b == b) &&
            (identical(other.attribute, attribute) ||
                other.attribute == attribute) &&
            (identical(other.printingmethod, printingmethod) ||
                other.printingmethod == printingmethod) &&
            (identical(other.databaseColor, databaseColor) ||
                other.databaseColor == databaseColor));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      type,
      book,
      egname,
      frequency,
      angle,
      dotshape,
      r,
      g,
      b,
      attribute,
      printingmethod,
      databaseColor);

  /// Create a copy of ArtworkColorSpecification
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ArtworkColorSpecificationImplCopyWith<_$ArtworkColorSpecificationImpl>
      get copyWith => __$$ArtworkColorSpecificationImplCopyWithImpl<
          _$ArtworkColorSpecificationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ArtworkColorSpecificationImplToJson(
      this,
    );
  }
}

abstract class _ArtworkColorSpecification extends ArtworkColorSpecification {
  const factory _ArtworkColorSpecification(
      {final String? name,
      final String? type,
      final String? book,
      final String? egname,
      final double? frequency,
      final double? angle,
      final String? dotshape,
      final double? r,
      final double? g,
      final double? b,
      final String? attribute,
      final String? printingmethod,
      final ArtworkColor? databaseColor}) = _$ArtworkColorSpecificationImpl;
  const _ArtworkColorSpecification._() : super._();

  factory _ArtworkColorSpecification.fromJson(Map<String, dynamic> json) =
      _$ArtworkColorSpecificationImpl.fromJson;

  @override
  String? get name;
  @override
  String? get type;
  @override
  String? get book;
  @override
  String? get egname;
  @override
  double? get frequency;
  @override
  double? get angle;
  @override
  String? get dotshape;
  @override
  double? get r;
  @override
  double? get g;
  @override
  double? get b;
  @override
  String? get attribute;
  @override
  String? get printingmethod;
  @override
  ArtworkColor? get databaseColor;

  /// Create a copy of ArtworkColorSpecification
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ArtworkColorSpecificationImplCopyWith<_$ArtworkColorSpecificationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

LayerInfo _$LayerInfoFromJson(Map<String, dynamic> json) {
  return _LayerInfo.fromJson(json);
}

/// @nodoc
mixin _$LayerInfo {
  String get name => throw _privateConstructorUsedError;
  bool get printable => throw _privateConstructorUsedError;
  bool get locked => throw _privateConstructorUsedError;

  /// Serializes this LayerInfo to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of LayerInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LayerInfoCopyWith<LayerInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LayerInfoCopyWith<$Res> {
  factory $LayerInfoCopyWith(LayerInfo value, $Res Function(LayerInfo) then) =
      _$LayerInfoCopyWithImpl<$Res, LayerInfo>;
  @useResult
  $Res call({String name, bool printable, bool locked});
}

/// @nodoc
class _$LayerInfoCopyWithImpl<$Res, $Val extends LayerInfo>
    implements $LayerInfoCopyWith<$Res> {
  _$LayerInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LayerInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? printable = null,
    Object? locked = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      printable: null == printable
          ? _value.printable
          : printable // ignore: cast_nullable_to_non_nullable
              as bool,
      locked: null == locked
          ? _value.locked
          : locked // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LayerInfoImplCopyWith<$Res>
    implements $LayerInfoCopyWith<$Res> {
  factory _$$LayerInfoImplCopyWith(
          _$LayerInfoImpl value, $Res Function(_$LayerInfoImpl) then) =
      __$$LayerInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, bool printable, bool locked});
}

/// @nodoc
class __$$LayerInfoImplCopyWithImpl<$Res>
    extends _$LayerInfoCopyWithImpl<$Res, _$LayerInfoImpl>
    implements _$$LayerInfoImplCopyWith<$Res> {
  __$$LayerInfoImplCopyWithImpl(
      _$LayerInfoImpl _value, $Res Function(_$LayerInfoImpl) _then)
      : super(_value, _then);

  /// Create a copy of LayerInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? printable = null,
    Object? locked = null,
  }) {
    return _then(_$LayerInfoImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      printable: null == printable
          ? _value.printable
          : printable // ignore: cast_nullable_to_non_nullable
              as bool,
      locked: null == locked
          ? _value.locked
          : locked // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LayerInfoImpl extends _LayerInfo {
  const _$LayerInfoImpl(
      {required this.name, required this.printable, required this.locked})
      : super._();

  factory _$LayerInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$LayerInfoImplFromJson(json);

  @override
  final String name;
  @override
  final bool printable;
  @override
  final bool locked;

  @override
  String toString() {
    return 'LayerInfo(name: $name, printable: $printable, locked: $locked)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LayerInfoImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.printable, printable) ||
                other.printable == printable) &&
            (identical(other.locked, locked) || other.locked == locked));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, printable, locked);

  /// Create a copy of LayerInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LayerInfoImplCopyWith<_$LayerInfoImpl> get copyWith =>
      __$$LayerInfoImplCopyWithImpl<_$LayerInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LayerInfoImplToJson(
      this,
    );
  }
}

abstract class _LayerInfo extends LayerInfo {
  const factory _LayerInfo(
      {required final String name,
      required final bool printable,
      required final bool locked}) = _$LayerInfoImpl;
  const _LayerInfo._() : super._();

  factory _LayerInfo.fromJson(Map<String, dynamic> json) =
      _$LayerInfoImpl.fromJson;

  @override
  String get name;
  @override
  bool get printable;
  @override
  bool get locked;

  /// Create a copy of LayerInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LayerInfoImplCopyWith<_$LayerInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FontInfo _$FontInfoFromJson(Map<String, dynamic> json) {
  return _FontInfo.fromJson(json);
}

/// @nodoc
mixin _$FontInfo {
  String get name => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get location => throw _privateConstructorUsedError;
  bool get protection => throw _privateConstructorUsedError;
  String? get fontFile => throw _privateConstructorUsedError;

  /// Serializes this FontInfo to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FontInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FontInfoCopyWith<FontInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FontInfoCopyWith<$Res> {
  factory $FontInfoCopyWith(FontInfo value, $Res Function(FontInfo) then) =
      _$FontInfoCopyWithImpl<$Res, FontInfo>;
  @useResult
  $Res call(
      {String name,
      String type,
      String location,
      bool protection,
      String? fontFile});
}

/// @nodoc
class _$FontInfoCopyWithImpl<$Res, $Val extends FontInfo>
    implements $FontInfoCopyWith<$Res> {
  _$FontInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FontInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? type = null,
    Object? location = null,
    Object? protection = null,
    Object? fontFile = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      location: null == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String,
      protection: null == protection
          ? _value.protection
          : protection // ignore: cast_nullable_to_non_nullable
              as bool,
      fontFile: freezed == fontFile
          ? _value.fontFile
          : fontFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FontInfoImplCopyWith<$Res>
    implements $FontInfoCopyWith<$Res> {
  factory _$$FontInfoImplCopyWith(
          _$FontInfoImpl value, $Res Function(_$FontInfoImpl) then) =
      __$$FontInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String type,
      String location,
      bool protection,
      String? fontFile});
}

/// @nodoc
class __$$FontInfoImplCopyWithImpl<$Res>
    extends _$FontInfoCopyWithImpl<$Res, _$FontInfoImpl>
    implements _$$FontInfoImplCopyWith<$Res> {
  __$$FontInfoImplCopyWithImpl(
      _$FontInfoImpl _value, $Res Function(_$FontInfoImpl) _then)
      : super(_value, _then);

  /// Create a copy of FontInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? type = null,
    Object? location = null,
    Object? protection = null,
    Object? fontFile = freezed,
  }) {
    return _then(_$FontInfoImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      location: null == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String,
      protection: null == protection
          ? _value.protection
          : protection // ignore: cast_nullable_to_non_nullable
              as bool,
      fontFile: freezed == fontFile
          ? _value.fontFile
          : fontFile // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FontInfoImpl extends _FontInfo {
  const _$FontInfoImpl(
      {required this.name,
      required this.type,
      required this.location,
      required this.protection,
      this.fontFile})
      : super._();

  factory _$FontInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$FontInfoImplFromJson(json);

  @override
  final String name;
  @override
  final String type;
  @override
  final String location;
  @override
  final bool protection;
  @override
  final String? fontFile;

  @override
  String toString() {
    return 'FontInfo(name: $name, type: $type, location: $location, protection: $protection, fontFile: $fontFile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FontInfoImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.protection, protection) ||
                other.protection == protection) &&
            (identical(other.fontFile, fontFile) ||
                other.fontFile == fontFile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, name, type, location, protection, fontFile);

  /// Create a copy of FontInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FontInfoImplCopyWith<_$FontInfoImpl> get copyWith =>
      __$$FontInfoImplCopyWithImpl<_$FontInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FontInfoImplToJson(
      this,
    );
  }
}

abstract class _FontInfo extends FontInfo {
  const factory _FontInfo(
      {required final String name,
      required final String type,
      required final String location,
      required final bool protection,
      final String? fontFile}) = _$FontInfoImpl;
  const _FontInfo._() : super._();

  factory _FontInfo.fromJson(Map<String, dynamic> json) =
      _$FontInfoImpl.fromJson;

  @override
  String get name;
  @override
  String get type;
  @override
  String get location;
  @override
  bool get protection;
  @override
  String? get fontFile;

  /// Create a copy of FontInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FontInfoImplCopyWith<_$FontInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
